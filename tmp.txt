server : driarc.com
user : administrator
pass : DRIadmin@2010

MongoLabs.com trugate, tempalte-77

"Put" http://driarc/executethis
[{"ParameterName":"executeThis","ParameterValue":"addToMongo"},{"ParameterName":"x","ParameterValue":"1"},{"Key":"wid","Value":"wid1"},
{"ParameterName":"Js","ParameterValue":"function (x, y){ return x + y; }"},
{"ParameterValue":"accesstoken",{"ParameterValue":"111111111"}]

Process
ExecuteThis accepts a paramterDTO, a paraemterDTO can have from one to unlimited fields
It produces dataModelDto, can have from one to unlimited fields

Then the code will fish out parameters executethis, accesstoken
Internally the 'left over' inbound parameters will be x, wid, js

The code will proceed to 'addtomongo'…you will add to mongo as a simple record:
Mongo format for wids:
{
    "_id": {
        "$oid": "51b9e32180c3811304175f4e"
    },
    "wid": "wid1",
    "x": "1",
    "js" : "function (x, y){ return x + y; }"
}

AddtoMongo should return what was added so the output of this call will be:
Result:
[{"Key":"x","Value":"1"},{"Key":"wid","Value":"wid1"},{"Key":"Js","Value":"function (x, y){ return x + y; }"}]

NEXT CALL
"Put" http://driarc/executethis
[{"ParameterName":"executeThis","ParameterValue":"JavaScript"},{"ParameterName":"beginInboundParameters","ParameterValue":"wid1"},{"Key":"y","Value":"2"}, {"ParameterValue":"accesstoken",{"ParameterValue":"111111111"}]

Then the code will fish out parameters executethis, accesstoken, beginInboundParameters from inboundParameters
The 'left over' inbound parameters will be y

Since beginInboundParameters exists, the code will readFromMong from the value of beginInboundParamters.  It will read 'wid1': inbound = inbound + get from mongo (beginInboundParameters).  It receives [{"Key":"x","Value":"1"},{"Key":"wid","Value":"wid1"},{"Key":"Js","Value":"function (x, y){ return x + y; }"}]

So now inboundParamters has these values
y:2, x:1, wid:wid1, x:1, JS: "function (x, y){ return x + y; }"

The case statement will go to 'Javascript'
It will look for parameter JS
It will execute "value: function (x, y){ return x + y; }" with parameters wid: wid1, x:1, y:2
Javascript will evaluate {value: 3}

ExecuteThis returns {value: 3}
Result:
[{"Key":"value","Value":"3"}]
[8/14/2013 1:39:42 PM] Roger Colburn: -
[8/14/2013 1:39:43 PM] Roger Colburn: High level logic of /ExecuteThis
Accept parameterDTO (unlimited number of parameters)
Remove reserved parameters from incoming parameters, store them as local variables
Do special calls: begininboundParamters or beginOutboundDTO
Do case statement of executeThis--if none found then do getFromMongo of value of ExecuteThis
Return dataModelDTO with results

Example
Assumption wid1={x:1, y:2, JS: "function (x, y){ return x + y; }"}

If we call /executethis {executethis:dri, a:b, c: d, accesstoken:1111111, beginInboundParameter=wid1}

Then the code will fish out parameters executethis, accesstoken, beginInboundParameters from inboundParameters
The 'left over' inbound parameters will be {a:b, c: d}

Since beginInboundParameters exists go read mongo, inbound = inbound + get from mongo (beginInboundParameters)..it gets {e:f}
so now inboundParameters =  {a:b, c: d,e:f}

The case statement will go to 'DRI'
It will call http://wiziapi.drillar.com/ButtonServe.svc/GetData/ExecuteWid?accessToken=111111111111&pagelength=4 with parameters  {a:b, c: d,e:f}
Note the only thing that changed in in that call was accessToken and the parameters  {a:b, c: d,e:f}
Assume DRI sends back a response {r:q, t:s}

ExecuteThis returns {r:q, t:s}



Example
Assumption wid1={x:1, y:2, JS: "value: function (x, y){ return x + y; }"}
wid3={executethis:dri, a:b, c: d, accesstoken:1111111, beginInboundParameter=wid1}
wid2={1: wid1, 2: wid3}

If we call /executethis {executethis:multiplewid, a:b, c: d, multiplewid:wid2, accesstoken:1111111}

Then the code will fish out parameters executethis, accesstoken
The 'left over' inbound parameters will be {a:b, c: d, multiplewid:wid1}

The case statement will go to 'MultipleWid'
It will multiplewid with {a:b, c: d, multiplewid:wid1 accesstoken:1111111}
it will fish out multiplewid, accesstoken
it will read wid1 and execute it (see prior example) send a:b c:D to it
It will return {value: 3}
The it will read wid3 and execute it send a:b c:D, value:3 to it
it will return  {r:q, t:s}
The system returns value:3, r:q, t(worry)


curl -X PUT -H "content-type: application/json"  http://odesk.phaniram.c9.io/executethis --data '[{"ParameterName":"executeThis","ParameterValue":"JavaScript"},{"ParameterName":"beginInboundParameters","ParameterValue":"wid1"},{"ParameterName":"y","ParameterValue":"2"}, {"ParameterName":"accesstoken","ParameterValue":"111111111"}]';

curl -X PUT -H "content-type: application/json"  http://odesk.phaniram.c9.io/executethis --data '[{"ParameterName":"executeThis","ParameterValue":"DRI"},{"ParameterName":"beginInboundParameters","ParameterValue":"wid1"},{"ParameterName":"y","ParameterValue":"2"}, {"ParameterName":"accesstoken","ParameterValue":"111111111"}]'

http://jsfiddle.net/gN9bE/1/
http://stackoverflow.com/questions/9091289/javascript-anonymous-function-call
http://nodejs.org/docs/v0.4.9/api/all.html#vm.runInNewContext
http://stackoverflow.com/questions/1271516/executing-anonymous-functions-created-using-javascript-eval
http://stackoverflow.com/questions/4359639/eval-with-variables-from-an-object-in-the-scope
http://www.hacksparrow.com/mongoskin-tutorial-with-examples.html

(function() {
    'use strict';                       //a function in strict mode
    var x = 17;                         //local x
    var evalX = eval("var x = 42; x");  //eval'ed x
    alert(x)                            //should still be 17
    alert(evalX);                       //42
}())


curl https://npmjs.org/install.sh | sh
http://stackoverflow.com/questions/7793811/convert-javascript-dot-notation-object-to-nested-object?rq=1

http://www.getpostman.com/collections/9b01c79e107971ab7f45
http://www.getpostman.com/collections/2bc81f2d1a866e29ea06

<script type="text/javascript" src="http://calltrack.nexussolutions.nl/referrer_dynjs.php?c_id=36"></script>
<script async src="//5175.tctm.co/t.js"></script>
<script async src="//8638.tctm.co/t.js"></script>

http://wiziapi.drillar.com/ButtonServe.svc/GetData/adddatawid?accessToken=2afe5025-1964-4c50-abcf-bcd558188e74
adds is a put call
that will add a wid value pairs

http://wiziapi.drillar.com/ButtonServe.svc/GetData/getalldata?accessToken=2afe5025-1964-4c50-abcf-bcd558188e74
will get the results of what is added if we send in this parameter
[{"ParameterName":"wid","ParameterValue":"eq:displayonewid"}]

parameters [{"ParameterName":"wid","ParameterValue":"aaabbb"},{"ParameterName":"test","ParameterValue":"xyz"}] to adddatawid

[{"ParameterName":"wid","ParameterValue":"eq:aaabbb"}] to getalldata
this call is always a put call with paramterdto in and data model out

http://wiziapi.drillar.com/ButtonServe.svc/GetData/getalldata?accessToken=2afe5025-1964-4c50-abcf-bcd558188e74  {parks…} is the same as
http://wiziapi.drillar.com/ButtonServe.svc/GetData/executewid?accessToken=2afe5025-1964-4c50-abcf-bcd558188e74 {parms + executewid:getalldata}

If testa={executwid:getalldata, a:eq:b} , then if "I" wanted to call DRI via your call I would call 
////executethis {executethis:DRI, begininboundparameters:testa} would do the same as the previous example

curl -X PUT -H "content-type: application/json"  http://odesk.phaniram.c9.io/executethis --data '[{"ParameterName":"executeThis","ParameterValue":"DRI"},{"ParameterName":"beginInboundParameters","ParameterValue":"wid1"},{"ParameterName":"ExecuteWid","ParameterValue":"adddatawid"},{"ParameterName":"y","ParameterValue":"2"}, {"ParameterName":"accesstoken","ParameterValue":"111111111"}]'

 from the original design doc:
ExecuteThis Pseudo Code
ExcuteThis(inboundparameters) produces OutboundParameters
// this code accepts inbound parameters, based on specific parameters the code splits up the execution stream to other functions

inboundParameters = incoming ParameterDTO      // convert to simple dictionary or array
OutParam = ""					// simple dictionary or array

// fishout special parameters and remove them from inboundParameters
accesstoken=get from inboundParameters, remove it from inboundbound parameters
beginInboundParameter (BIP)=get from inboundParameters, remove it from inboundbound parameters
beginOutboundDTO (BOD)=get from inboundParameters, remove it from inboundbound parameters
ExecuteThis=get from inboundParameters, remove it from inboundbound parameters

// If SecurityCheck(accesstoken, wid) then continue

If beginInboundParameter (BIP) exists then
		inboundParameters = inboundParameters + getFromMongo(wid=<BIP>)    // add to inbound parameters by getting more from Mongo
If beginOutboundDTO (BOD) exists then
		filterParams = getfromMongo(wid=beginOutboundDTO (BOD))
//		inboundParameters=convertparameters(DTOParams=FilterParams, TargetParams=inboundParameters)
		
Case of ExecuteThis:
	JavaScript
		JS=get from inboundParameters, remove it from inboundbound parameters
		OutParm = Execute: OutParam = evaluate JavaScript ( <JS> {inboundParameters})
	MongoJavaScript
		JS=get from inboundParameters, remove it from inboundbound parameters
		OutParm = mongo.eval(<JS> {inboundParameters{)
	DRI
		OutParm = ExecuteDRI(inboungParameters + accesstoken)
//	AddWidMaster 
//		OutParam=AddWidMaster(inboundParameters + accesstoken)
//	GetWidMaster
//		OutParm=getWidMaster(inboundParameters + accesstoken + DTOType="Raw")
	MultipleMongo
		OutParam = executeMultiple (inboundParameters + accesstoken)

	else outParam = getFromMongo(wid=ExecuteThis) 
return outParm in DTOModel format


ExecuteMultiple Pseudo Code
ExecuteMultiple (inboundParameters) produces OutboundParameters 
// this code reads a mongo record, then for each item in the record it trys to call excuteThis (recurse)
accesstoken=get from inboundParameters, remove it from inboundbound parameters
multipleWid=get from inboundParameters, remove it from inboundbound parameters
ExecuteList = getFromMongo(wid=<multiplewid>)
	For each item returned, sort in <left> order: 
	OutParam = OutParam + ExecuteThis {OutParm + InboundParameters}  // recurse to the main call
[21:48:17] Roger Colburn: regardless…don't worry about mongoJavascript…since mongo is having a problem with that…DO do executeMultiple
[21:48:22] Roger Colburn: let me know what questions you have
[21:55:24] Roger Colburn: This was the original spec of getdata/multiple

multiplewid			wid to be read
multipleexecute			
	<wid>			wid to be executed 
	left			wid to be executed in left
	right			wid to be execute in right

multipleparameters: 
	<wid>			wid with parameters
	left			parameters in left
	right			parameters in right


Here are some clarifications
For parameters part of this the system always checks for json (i.e. {a:b, c:d}, if not json, then it does a getdata to get the data).  We already do this for datawid/dataparms
If left is not mentioned (if multipleexecute<>left and multipleparameter<>left) then order the list by the number in the left side (i.e. execute in order)
	use the parameters from the previous call, chain parameters


examples
test1
1 wid1
2 wid2
3 wid3

1
getdata/multiple {multiplewid=test1, multipleexecute=right, multipleparameters="") would execute wid1 and then wid2 and then wid3, the results of wid1 would be sent in to wid2, the results of wid2 would be sent into wid3, etc.

2
getdata/multiple {multiplewid=test1, multipleexecute=masterexecute, multipleparameters=right) would execute getdata/masterexecute {parameters=wid1} and then getdata/masterexecute {parameters=wid2} and then getdata/masterexecute {parameters=wid3}, the results of wid1 would be sent in to wid2, the results of wid2 would be sent into wid3, etc.

wid1 and wid2 would need to have inside of them parameters masterexecute needs: wid1={executewid=xyz, e:f, g:h} wid2={executewid=abc, x:y}

test1
1 wid1
2 wid2
3 {executewid:wid3, a:b, c:d} 
Note, the system always checks for json then wid, so this should have also worked [3 would be  getdata/masterexecute{executewid:wid3, a:b, c:d}]

3
test2
parm1 		wid1
parm2 		wid2
{a:b, c:d}  	wid3
getdata/multiple {multiplewid=test2, multipleexecute=right, multipleparameters=left) would execute wid1 with the parameters in parm1 and then wid2 with parameters in parm2 and then wid3 with parameters {a:b, c:d} 

4
test3
wid1 parm1 		
wid2 parm2 		
wid3 {a:b, c:d}  	
getdata/multiple {multiplewid=test3, multipleexecute=left, multipleparameters=right) would execute wid1 with the parameters in parm1 and then wid2 with parameters in parm2 and then wid3 with parameters {a:b, c:d}
[21:55:42] Roger Colburn: that is what we do in our real system…but your version can be much simpler
[21:55:46] Roger Colburn: read from mongo
[21:56:10] Roger Colburn: for every record that comes back, iterate to execute this

 
 git@heroku.com:nodejsmtapi.git
 
 
wget http://assets.heroku.com/heroku-client/heroku-client.tgz
tar xzfv heroku-client.tgz
cd heroku-client/bin
PATH=$PATH:$PWD 