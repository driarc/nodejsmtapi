        public List<DataModelDTO> GetMongoEnhanced(List<ParameterDTO> parameters)
        {
            // Mongo query structure is generically $AND[$OR, $OR, $OR, etc.].
            // Any parameteres left over are the 1st $OR section. If those are the
            // only parameters, or if the querywid only has one wid inside it,
            // there will be no $AND, just the $OR by itself.
            // Any wids inside of the MongoQUeryWid will hold the parameters for
            // another $OR section of the query string.

            #region Variable Bullpen
            List<DataModelDTO> returnValues = new List<DataModelDTO>();
            List<string> ListOfWidNames = new List<string>();
            List<DataModelDTO> ListOfKVP = new List<DataModelDTO>();
            List<DataModelDTO> tempListOfKVP = new List<DataModelDTO>();

            List<List<DataModelDTO>> ListsOfOrGroups = new List<List<DataModelDTO>>();

            // Methods of MongoQBuilder accept strings or List<DataModelDTO> to build an $OR section.
            var qb = new MongoQBuilder(); 

            string connectionString = ConfigurationManager.AppSettings["MongoDBConnection"];
            string dataBaseName = ConfigurationManager.AppSettings["MongoDB"];
            var collectionName = ConfigurationManager.AppSettings["MongoDBCollection"];
            string MongoQueryWid = string.Empty;
            string MongoQueryType = string.Empty;
            string MQueryString = string.Empty;

            string mongoRelationshipDirection = string.Empty;
            string mongoRelationshipType = string.Empty;
            string mongoRelationshipMethod = string.Empty;
            string mongoRelationshipRawQuery = string.Empty;
            string mongoRelationshipQuery = string.Empty;
            string mongoToken = string.Empty;

            string mongoSetFieldsInclude = string.Empty;
            string mongoSetFieldsExclude = string.Empty;
            string mongoSetLimit = string.Empty;
            string mongoSetSkip = string.Empty;
            string mongoSetHint = string.Empty;
            string mongoSetMax = string.Empty;
            string mongoSetSortBy = string.Empty;
            string mongoReturnCount = string.Empty;
            string mongoExplain = string.Empty;
            string mongoSize = string.Empty;
            string mongoSetSortOrder = string.Empty;
    		string mongoAggregation = string.Empty;
			string mongoDTOType = string.Empty;

            var tempDataModelDTO = new DataModelDTO();
            #endregion

            #region Fishing Out Parameter Keywords
            // Fish out the keywords from the parameterDTO's Set to GME

			if (parameters.Any(p => p.ParameterName.ToLower() == "mongodtotype"))
			{
				mongoDTOType = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongodtotype").ParameterValue;
				parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongodtotype"));
			}

			if (parameters.Any(p => p.ParameterName.ToLower() == "mongoaggregation"))
			{
				mongoAggregation = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongoaggregation").ParameterValue;
				parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongoaggregation"));
			}

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongocollection"))
            {
                collectionName = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongocollection").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongocollection"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongoconnectionstring"))
            {
                connectionString = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongoconnectionstring").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongoconnectionstring"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongodatabase"))
            {
                dataBaseName = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongodatabase").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongodatabase"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongorelationshipdirection"))
            {
                mongoRelationshipDirection = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongorelationshipdirection").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongorelationshipdirection"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongorelationshiptype"))
            {
                mongoRelationshipType = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongorelationshiptype").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongorelationshiptype"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongorelationshipmethod"))
            {
                mongoRelationshipMethod = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongorelationshipmethod").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongorelationshipmethod"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongorelationshiprawquery"))
            {
                mongoRelationshipRawQuery = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongorelationshiprawquery").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongorelationshiprawquery"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongorelationshipquery"))
            {
                mongoRelationshipQuery = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongorelationshipquery").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongorelationshipquery"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "at"))
            {
                mongoToken = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "at").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "at"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongosetfieldsinclude"))
            {
                mongoSetFieldsInclude = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetfieldsinclude").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetfieldsinclude"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongosetfieldsexclude"))
            {
                mongoSetFieldsExclude = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetfieldsexclude").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetfieldsexclude"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongosetlimit"))
            {
                mongoSetLimit = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetlimit").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetlimit"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongosetlimit"))
            {
                mongoSetLimit = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetlimit").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetlimit"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongosetskip"))
            {
                mongoSetSkip = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetskip").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetskip"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongosethint"))
            {
                mongoSetHint = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosethint").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosethint"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongosetmax"))
            {
                mongoSetMax = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetmax").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetmax"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongosetsortorder"))
            {
                mongoSetSortOrder = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetsortorder").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetsortorder"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongosetsortby"))
            {
                mongoSetSortBy = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetsortby").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosetsortby"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongoreturncount"))
            {
                mongoReturnCount = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongoreturncount").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongoreturncount"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongoexplain"))
            {
                mongoExplain = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongoexplain").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongoexplain"));
            }

            if (parameters.Any(p => p.ParameterName.ToLower() == "mongosize"))
            {
                mongoSize = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosize").ParameterValue;
                parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "mongosize"));
            }
            #endregion

            #region Fishing Out MongoQueryType
            // Search to see that there is a parameter about mongo queries in the parameters
            try
            {
                if (parameters.Any(p => p.ParameterName.ToLower() == "rawmongoquery"))
                    MongoQueryType = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "rawmongoquery").ParameterName;

                if (parameters.Any(p => p.ParameterName.ToLower() == "singlemongoquery"))
                {
                    MongoQueryType = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "singlemongoquery").ParameterName;
                    MongoQueryWid = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "singlemongoquery").ParameterValue;
                }

                if (parameters.Any(p => p.ParameterName.ToLower() == "multiplemongoquery"))
                {
                    MongoQueryType = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "multiplemongoquery").ParameterName;
                    MongoQueryWid = parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "multiplemongoquery").ParameterValue;
                    parameters.Remove(parameters.FirstOrDefault(p => p.ParameterName.ToLower() == "multiplemongoquery"));

                }
            }
            catch
            {
                returnValues.Add(new DataModelDTO() { Key = "Error", Value = "Get Mongo Enhanced Query parameter not found" });
            }

            #endregion

            #region Set up the database connection
            // Set up the connection to the db
            var client = new MongoClient(connectionString);
            var server = client.GetServer();
            var dataBase = server.GetDatabase(dataBaseName);
            var collection = dataBase.GetCollection(collectionName); 
            #endregion

            #region MAIN NON-RELATIONSHIP SECTION
            switch (MongoQueryType.ToLower())
            {
                #region Cases for Query Types
                case "rawmongoquery":
                    {
                        // Build the query and execute it
                        if (parameters.Any(q => q.ParameterName.ToLower() == "rawmongoquery"))
                            MQueryString = parameters.FirstOrDefault(q => q.ParameterName.ToLower() == "rawmongoquery").ParameterValue;
                    }
                    break;
                // simplemongoquery is not used and is there for testing only
                case "simplemongoquery":
                    {
                        var tempKey = string.Empty;
                        var tempValue = string.Empty;

                        if (parameters.Any(q => q.ParameterName.ToLower() == "mkey"))
                            tempKey = parameters.FirstOrDefault(q => q.ParameterName.ToLower() == "mkey").ParameterValue;
                        if (parameters.Any(q => q.ParameterName.ToLower() == "mvalue"))
                            tempValue = parameters.FirstOrDefault(q => q.ParameterName.ToLower() == "mvalue").ParameterValue;
                        var qBuilder = new MongoQBuilder();
                        MQueryString = qBuilder.BuildSimpleQuery(tempKey, tempValue);
                    }
                    break;

                case "singlemongoquery":
                    {
                        // gets parameters of query e.b. key:value of q1

                        List<DataModelDTO> tempDtoList = GetDataValuePairs(MongoQueryWid, accessToken, userInfo, parameters);
                        var qBuilder = new MongoQBuilder();
                        MQueryString = qBuilder.BuildSingleQuery(tempDtoList);
                    }
                    break;

                case "multiplemongoquery":
                    {
                        // At this point, the keywords are fished out. The parameters that are left will be key:value ParameterDTO.
                        // Now that the widnames and keywords are fished out, the rest of the ParameterDTO's can be 
                        // converted to DataModelDTO's
						//if (parameters.Count > 0)
						//{
						//    var tempKVP = new List<DataModelDTO>();
						//    foreach (ParameterDTO mp in parameters)
						//    {
						//        tempDataModelDTO.Key = mp.ParameterName;
						//        tempDataModelDTO.Value = mp.ParameterValue;
						//        tempKVP.Add(tempDataModelDTO);
						//    }
						//    ListsOfOrGroups.Add(tempKVP);
						//}

                        // Use MongoQueryWid to get wids to look up.
                        // If the kvp is a widname, add the name to the list of names or add the kvp to the ListOfKVP
                        try
                        {
							tempListOfKVP = GetDataValuePairs(MongoQueryWid, mongoToken, userInfo, parameters);
                        }
                        catch
                        {
                            returnValues.Add(new DataModelDTO() { Key = "Error", Value = "'multiplemongoquery' wid not found in database." });
                            return returnValues;

                        }
                        // All values in MongoQueryWid are wids to look up, so add to ListOfWidNames

                        foreach (DataModelDTO t in tempListOfKVP)
                        {
                            ListOfWidNames.Add(t.Key);
                        }
                        // Get the kvp out of the List of widNames that came from the ParameterDTO's and the multipleWid.
                        // Any wid will act as it's own group, starting at 1 since the loose parameterDTO's are the first $OR group.
                        foreach (string wname in ListOfWidNames)
                        {
							tempListOfKVP = GetDataValuePairs(wname, mongoToken, userInfo, parameters);
                          
                            if (tempListOfKVP.Count == 0) 
                            {
                                returnValues.Add(new DataModelDTO() { Key = "Error", Value = "Parameter wid from 'multiplemongoquery' wid not found in database." });
                                return returnValues;
                            }                       
                            ListsOfOrGroups.Add(tempListOfKVP);
                        }

                        // Don't run this code if there are no lists to build
                        if (ListsOfOrGroups.Count > 0)
                        {
                            MQueryString = qb.BuildMultipleQuery(ListsOfOrGroups);
                        }
                        else
                        {
                            returnValues.Add(new DataModelDTO() { Key = "Error", Value = "Failed in query building. No parameters to build with." });
							return returnValues;
                        }
                    }
                    break;
                #endregion
            } // End of queryType switch

			if (string.IsNullOrEmpty(MQueryString))
			{
				returnValues.Add(new DataModelDTO() { Key = "Error", Value = "There is no query string to use. Try another wid to look up." });
				return returnValues;
			}

            var qdoc = new QueryDocument(BsonDocument.Parse(MQueryString));
            var mycursor = collection.Find(qdoc);

            // Make sure there is something to look for
            if (MQueryString != "")
            {
                // var mycursor = collection.Find(qdoc);
                returnValues = AssembleMongoResults(mycursor); 
            #endregion

            #region RELATIONSHIP SECTION
                // Check to see if you get 1 param but not the other.
                if (((mongoRelationshipDirection != string.Empty) && (mongoRelationshipType == string.Empty)) || (mongoRelationshipDirection == string.Empty) && (mongoRelationshipType != string.Empty))
                {
                    returnValues.Add(new DataModelDTO() { Key = "Error", Value = "For relationship queries, you need BOTH direction and type." });
                }

                // Check for relationship parameters

                if (mongoRelationshipDirection != string.Empty && mongoRelationshipType != string.Empty)
                {
                    // Clear out some lists to use.
                    ListOfWidNames.Clear();
                    ListsOfOrGroups.Clear();
                    ListOfKVP.Clear();

                    string dir = string.Empty;
                    if (mongoRelationshipDirection.ToLower() == "forward") dir = "primarywid";
                    if (mongoRelationshipDirection.ToLower() == "reverse") dir = "secondarywid";

                    // Pull out the widnames from the results.
                    foreach (DataModelDTO v in returnValues)
                    {
                        if (v.Key == "wid")
                        {
                            ListOfWidNames.Add(v.Value);
                        }
                    }

                    // Make an $OR group out of the widnames
                    foreach (string n in ListOfWidNames)
                    {
						//tempDataModelDTO.Key = dir;
						//tempDataModelDTO.Value = n;
						ListOfKVP.Add(new DataModelDTO() { Key = dir, Value = n });
                    }
                    ListsOfOrGroups.Add(ListOfKVP);

                    // Check to see if any names were found before making the relationshiptype list
                    // Make an $OR group out of the mongorelationshiptype

                    if (ListsOfOrGroups.Count > 0)
                    {
                        var tmplist = new List<DataModelDTO>();
						//var tmp = new DataModelDTO();
						//tmp.Key = "relationshiptype";
						//tmp.Value = mongoRelationshipType;

						tmplist.Add(new DataModelDTO() { Key = "relationshiptype", Value = mongoRelationshipType });
                        ListsOfOrGroups.Add(tmplist);
                    }

                    // Now that the lists of $OR groups are made, build the query
                    // Don't run this code if there are no lists to build
                    if (ListsOfOrGroups.Count > 0)
                    {

                        MQueryString = qb.BuildMultipleQuery(ListsOfOrGroups);
                        
                        qdoc = new QueryDocument(BsonDocument.Parse(MQueryString));
                        mycursor = collection.Find(qdoc);
                        returnValues = AssembleMongoResults(mycursor);

                        // Now that all the relationships have been returned, it's time to fish out the appropriate wids and get them
                        if (mongoRelationshipDirection.ToLower() == "forward") dir = "secondary";
                        if (mongoRelationshipDirection.ToLower() == "reverse") dir = "primary";

                        // Make a new list of widnames out of the returned values from the relationhsip
                        ListOfKVP.Clear();
                        foreach (DataModelDTO d in returnValues)
                        {
                            if (d.Key == dir)
                            {
                                //ListOfWidNames.Add(d.Value);
                                ListOfKVP.Add(new DataModelDTO() { Key = "wid", Value = d.Value });
                            }
                        }

                        // Clear Lists and start building listsoforgroups with names
                        ListsOfOrGroups.Clear();
                        ListsOfOrGroups.Add(ListOfKVP);

                        // Add a raw query to Lists
                        if (mongoRelationshipRawQuery != string.Empty)
                        {
                            ListsOfOrGroups.Add(new List<DataModelDTO>() { new DataModelDTO() { Key = "rawquery", Value = mongoRelationshipRawQuery } });
                        }

                        // Add a query wid to Lists
                        if (mongoRelationshipQuery != string.Empty)
                        {
                            ListsOfOrGroups.Add(GetDataValuePairs(mongoRelationshipQuery, mongoToken, userInfo, parameters));
                        }

						// Look for MongoDTOType and add it to the list of groups for query
						if (mongoDTOType != string.Empty)
						{
							ListsOfOrGroups.Add(new List<DataModelDTO>() { new DataModelDTO() { Key = "method", Value = mongoDTOType } });
						}

						// Generate relationship query doc

                        MQueryString = qb.BuildMultipleQuery(ListsOfOrGroups);
                        qdoc = new QueryDocument(BsonDocument.Parse(MQueryString));
						if (mongoAggregation != string.Empty)
						{
							returnValues.Clear(); 
							mycursor = collection.Find(qdoc);
							returnValues = AssembleMongoResults(mycursor);
						}

                        #region Old location for Add Ons
                        //// Finally... query with add-ons
                        //// These will pull values from the fished out keywords, or assign actual defaults.

                        //#region Query Addon defaults
                        //string defaultFieldsInclude = (mongoSetFieldsInclude == string.Empty) ? string.Empty : mongoSetFieldsInclude;
                        //string defaultFieldsExclude = (mongoSetFieldsExclude == string.Empty) ? "_id" : mongoSetFieldsExclude;       // this doesn't work either:  "{\"_id\",\"a\"}";
                        //Int32 defaultLimit = (mongoSetLimit == string.Empty) ? 999999999 : Convert.ToInt32(mongoSetLimit);
                        //Int32 defaultSkip = (mongoSetSkip == string.Empty) ? 0 : Convert.ToInt32(mongoSetSkip);
                        //string defaultSortBy = (mongoSetSortBy == string.Empty) ? "_id" : mongoSetSortBy;
                        //string defaultSortOrder = (SortOrder == string.Empty) ? "ascending" : SortOrder;
                        //Int32 defaultSetMax = (mongoSetMax == string.Empty) ? 999999999 : Convert.ToInt32(mongoSetMax);
                        //string defaultHint = (mongoSetHint == string.Empty) ? "_id" : mongoSetHint;
                        //bool defaultCount = (mongoReturnCount == string.Empty) ? false : true;
                        //bool defaultExplain = (mongoExplain == string.Empty) ? false : true;
                        //bool defaultSize = (Size == string.Empty) ? false : true;

                        //collection.EnsureIndex(IndexKeys.Ascending(defaultHint), IndexOptions.SetName("myIndex"));

                        //// Dealing with method is setting the defaults accordingly
                        //if (mongoRelationshipMethod == "first")
                        //{
                        //    defaultLimit = 1;
                        //}
                        //if (mongoRelationshipMethod == "last")
                        //{
                        //    defaultLimit = 1;
                        //    defaultSortOrder = "descending";
                        //}
                        //#endregion

                        //#region Executing Addons
                        //// Need different functions for ascending and descending
                        //// Ascending Section
                        //if (defaultSortOrder != "descending")
                        //{
                        //    // Count ignores the limit or skip, so it will return all the matching records.count regardless of limit or skip.
                        //    if (defaultCount)
                        //    {
                        //        returnValues.Clear();
                        //        returnValues.Add(new DataModelDTO()
                        //        {
                        //            Key = "Number of documents found is",
                        //            Value = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).mongoSetHint(new BsonDocument(defaultHint, 1))
                        //                .mongoSetLimit(defaultLimit).mongoSetSkip(defaultSkip).mongoSetSortOrder(SortBy.Ascending(defaultSortBy)).Count().ToString()
                        //        });
                        //    }
                        //    // mongoExplain returns the statistics of the query, not the query itself.
                        //    if (defaultExplain)
                        //    {
                        //        returnValues.Clear();
                        //        returnValues.Add(new DataModelDTO()
                        //        {
                        //            Key = "The query statistics are as follows",
                        //            Value = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).mongoSetHint(new BsonDocument(defaultHint, 1))
                        //                .mongoSetLimit(defaultLimit).mongoSetSkip(defaultSkip).mongoSetSortOrder(SortBy.Ascending(defaultSortBy)).mongoExplain().ToString()
                        //        });
                        //    }
                        //    // mongoSize will return an int of the number of records, but unlike count, it takes into account the limit and skip
                        //    if (defaultSize)
                        //    {
                        //        returnValues.Clear();
                        //        returnValues.Add(new DataModelDTO()
                        //        {
                        //            Key = "Number of documents found is",
                        //            Value = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).mongoSetHint(new BsonDocument(defaultHint, 1))
                        //                .mongoSetLimit(defaultLimit).mongoSetSkip(defaultSkip).mongoSetSortOrder(SortBy.Ascending(defaultSortBy)).mongoSize().ToString()
                        //        });
                        //    }

                        //    if (!defaultCount && !defaultExplain && !defaultSize)
                        //    {
                        //        mycursor = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).mongoSetHint(new BsonDocument(defaultHint, 1))
                        //                    .mongoSetLimit(defaultLimit).mongoSetSkip(defaultSkip).mongoSetSortOrder(SortBy.Ascending(defaultSortBy));
                        //    }
                        //}
                        //// Descending Section
                        //else
                        //{
                        //    // Count ignores the limit or skip, so it will return all the matching records.count regardless of limit or skip.
                        //    if (defaultCount)
                        //    {
                        //        returnValues.Clear();
                        //        returnValues.Add(new DataModelDTO()
                        //        {
                        //            Key = "Number of documents found is",
                        //            Value = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).mongoSetHint(new BsonDocument(defaultHint, 1))
                        //                .mongoSetLimit(defaultLimit).mongoSetSkip(defaultSkip).mongoSetSortOrder(SortBy.Descending(defaultSortBy)).Count().ToString()
                        //        });
                        //    }
                        //    // mongoExplain returns the statistics of the query, not the query itself.
                        //    if (defaultExplain)
                        //    {
                        //        returnValues.Clear();
                        //        returnValues.Add(new DataModelDTO()
                        //        {
                        //            Key = "The query statistics are as follows",
                        //            Value = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).mongoSetHint(new BsonDocument(defaultHint, 1))
                        //                .mongoSetLimit(defaultLimit).mongoSetSkip(defaultSkip).mongoSetSortOrder(SortBy.Descending(defaultSortBy)).mongoExplain().ToString()
                        //        });
                        //    }
                        //    // mongoSize will return an int of the number of records, but unlike count, it takes into account the limit and skip
                        //    if (defaultSize)
                        //    {
                        //        returnValues.Clear();
                        //        returnValues.Add(new DataModelDTO()
                        //        {
                        //            Key = "Number of documents found is",
                        //            Value = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).mongoSetHint(new BsonDocument(defaultHint, 1))
                        //                .mongoSetLimit(defaultLimit).mongoSetSkip(defaultSkip).mongoSetSortOrder(SortBy.Descending(defaultSortBy)).mongoSize().ToString()
                        //        });
                        //    }
                        //    // The count, explain, and size are all calls that don't return records...
                        //    // So don't use mycursor to get the records if you don't want them
                        //    if (!defaultCount && !defaultExplain && !defaultSize)
                        //    {
                        //        mycursor = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).mongoSetHint(new BsonDocument(defaultHint, 1))
                        //                    .mongoSetLimit(defaultLimit).mongoSetSkip(defaultSkip).mongoSetSortOrder(SortBy.Descending(defaultSortBy));
                        //    }
                        //}

                        //if (!defaultCount && !defaultExplain && !defaultSize)
                        //{
                        //    returnValues = AssembleMongoResults(mycursor);
                        //}
                        //#endregion 
                        #endregion

                    }
                    else
                    {
                        returnValues.Add(new DataModelDTO() { Key = "Error", Value = "Failed in query building. No parameters to build with." });
                    }
                } // End if there is a relationship
            }
            #endregion

            else // End if there is a MQueryString
            {
                returnValues.Add(new DataModelDTO() { Key = "Error", Value = "Get Mongo Enhanced Query parameter not found" });
				return returnValues;
            }

			#region Aggregation

			if (!string.IsNullOrEmpty(mongoAggregation) && returnValues.Count > 0)
			{
				// Pull out widnames anb build aggregate string
				var originalQery = "{\"$match\":{\"wid\":{\"$in\":[";
				foreach (DataModelDTO d in returnValues)
				{
					if (d.Key == "wid")
					{
						originalQery += "\"" + d.Value + "\",";
					}
				}
				originalQery = originalQery.Remove(originalQery.Length - 1, 1);
				originalQery += "]}}}";


				returnValues.Clear();
				var deserializedOriginalQuery = MongoDB.Bson.Serialization.BsonSerializer.Deserialize<BsonDocument>(originalQery);
				var deserializedJsonQueryString = MongoDB.Bson.Serialization.BsonSerializer.Deserialize<BsonDocument>(mongoAggregation);
				// Put the 2 query docs in the pipeline
				var pipeline = new[] { deserializedOriginalQuery, deserializedJsonQueryString };
				MongoDB.Driver.AggregateResult results = collection.Aggregate(pipeline);

				foreach (var stuff in results.ResultDocuments)
				{
					string data = stuff.ToString();
					var index = data.IndexOf(",");
					// Remove everything up to the actual name of the wid
					data = data.Remove(0, index + 11);
					//data = data.Replace("\\", "");
					index = data.IndexOf(",");
					var tempkey = data.Substring(0, index - 1);
					data = data.Remove(0, index + 1);
					index = data.Length - 1;
					var tempvalue = "{" + data.Remove(index) + "}";
					tempkey = "Your agg results are:";
					returnValues.Add(new DataModelDTO() { Key = tempkey, Value = tempvalue });
				}
				return returnValues;
			}
			else
			{
				returnValues.Clear();
				returnValues.Add(new DataModelDTO() { Key = "Failure", Value = "Related wids not found to perform aggregation on. Possibly due to methodDTOType not found in the result set." });
				return returnValues;

			}
			#endregion

            #region Add Ons
            // Finally... query with add-ons
            // These will pull values from the fished out keywords, or assign actual defaults.

            #region Query Addon defaults

            string[] defaultFieldsInclude = { "placehoder1", "placehoder2", "placehoder3", "placehoder4", "placehoder5", "placehoder6", "placehoder7", "placehoder8", "placehoder9", "placehoder10", "placehoder11", "placehoder12" };
            string[] defaultFieldsExclude = { "_id", "placehoder2", "placehoder3", "placehoder4", "placehoder5", "placehoder6", "placehoder7", "placehoder8", "placehoder9", "placehoder10", "placehoder11", "placehoder12" };

            if (mongoSetFieldsExclude != string.Empty)
            {
                tempListOfKVP = GetDataValuePairs(mongoSetFieldsExclude, mongoToken, userInfo, null);
                var i = 0;
                foreach (DataModelDTO d in tempListOfKVP)
                {
                    defaultFieldsExclude[i] = d.Key;
                    i++;
                }
            }

            if (mongoSetFieldsInclude != string.Empty)
            {
                tempListOfKVP = GetDataValuePairs(mongoSetFieldsInclude, mongoToken, userInfo, null);
                var i = 0;
                foreach (DataModelDTO d in tempListOfKVP)
                {
                    defaultFieldsInclude[i] = d.Key;
                    i++;
                }
            }

            Int32 defaultLimit      = (mongoSetLimit == string.Empty) ? 999999999 : Convert.ToInt32(mongoSetLimit);
            Int32 defaultSkip       = (mongoSetSkip == string.Empty) ? 0 : Convert.ToInt32(mongoSetSkip);
            string defaultSortBy    = (mongoSetSortBy == string.Empty) ? "_id" : mongoSetSortBy;
            string defaultSortOrder = (mongoSetSortOrder == string.Empty) ? "ascending" : mongoSetSortOrder;
            Int32 defaultSetMax     = (mongoSetMax == string.Empty) ? 999999999 : Convert.ToInt32(mongoSetMax);

            string defaultHint      = (mongoSetHint == string.Empty) ? "_id" : mongoSetHint;
            bool defaultCount       = (mongoReturnCount == string.Empty) ? false : true;
            bool defaultExplain     = (mongoExplain == string.Empty) ? false : true;
            bool defaultSize        = (mongoSize == string.Empty) ? false : true;

			try
			{
				collection.EnsureIndex(IndexKeys.Ascending(defaultHint), IndexOptions.SetName("myIndex"));

			}
			catch (Exception ex)
			{
				returnValues.Add(new DataModelDTO() { Key = "Failure", Value = "Error ensuring index on mongo collection. Look to use authorized credentials." });
				
			}
            // Dealing with method is setting the defaults accordingly
            if (mongoRelationshipMethod == "first")
            {
                defaultLimit = 1;
            }
            if (mongoRelationshipMethod == "last")
            {
                defaultLimit = 1;
                defaultSortOrder = "descending";
            }
            #endregion

            #region Executing Addons
            // Need different functions for ascending and descending
            // Ascending Section
            if (defaultSortOrder != "descending")
            {
                // Count ignores the limit or skip, so it will return all the matching records.count regardless of limit or skip.
                if (defaultCount)
                {
                    returnValues.Clear();
                    returnValues.Add(new DataModelDTO()
                    {
                        Key = "Number of documents found is",
                        Value = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).SetHint(new BsonDocument(defaultHint, 1))
                            .SetLimit(defaultLimit).SetSkip(defaultSkip).SetSortOrder(SortBy.Ascending(defaultSortBy)).Count().ToString()
                    });
                }
                // mongoExplain returns the statistics of the query, not the query itself.
                if (defaultExplain)
                {
                    returnValues.Clear();
                    returnValues.Add(new DataModelDTO()
                    {
                        Key = "The query statistics are as follows",
                        Value = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).SetHint(new BsonDocument(defaultHint, 1))
                            .SetLimit(defaultLimit).SetSkip(defaultSkip).SetSortOrder(SortBy.Ascending(defaultSortBy)).Explain().ToString()
                    });
                }
                // mongoSize will return an int of the number of records, but unlike count, it takes into account the limit and skip
                if (defaultSize)
                {
                    returnValues.Clear();
                    returnValues.Add(new DataModelDTO()
                    {
                        Key = "Number of documents found is",
                        Value = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).SetHint(new BsonDocument(defaultHint, 1))
                            .SetLimit(defaultLimit).SetSkip(defaultSkip).SetSortOrder(SortBy.Ascending(defaultSortBy)).Size().ToString()
                    });
                }

                if (!defaultCount && !defaultExplain && !defaultSize)
                {
                    mycursor = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).SetHint(new BsonDocument(defaultHint, 1))
                                .SetLimit(defaultLimit).SetSkip(defaultSkip).SetSortOrder(SortBy.Ascending(defaultSortBy));
                }
            }
            // Descending Section
            else
            {
                // Count ignores the limit or skip, so it will return all the matching records.count regardless of limit or skip.
                if (defaultCount)
                {
                    returnValues.Clear();
                    returnValues.Add(new DataModelDTO()
                    {
                        Key = "Number of documents found is",
                        Value = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).SetHint(new BsonDocument(defaultHint, 1))
                            .SetLimit(defaultLimit).SetSkip(defaultSkip).SetSortOrder(SortBy.Descending(defaultSortBy)).Count().ToString()
                    });
                }
                // mongoExplain returns the statistics of the query, not the query itself.
                if (defaultExplain)
                {
                    returnValues.Clear();
                    returnValues.Add(new DataModelDTO()
                    {
                        Key = "The query statistics are as follows",
                        Value = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).SetHint(new BsonDocument(defaultHint, 1))
                            .SetLimit(defaultLimit).SetSkip(defaultSkip).SetSortOrder(SortBy.Descending(defaultSortBy)).Explain().ToString()
                    });
                }
                // mongoSize will return an int of the number of records, but unlike count, it takes into account the limit and skip
                if (defaultSize)
                {
                    returnValues.Clear();
                    returnValues.Add(new DataModelDTO()
                    {
                        Key = "Number of documents found is",
                        Value = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).SetHint(new BsonDocument(defaultHint, 1))
                            .SetLimit(defaultLimit).SetSkip(defaultSkip).SetSortOrder(SortBy.Descending(defaultSortBy)).Size().ToString()
                    });
                }
                // The count, explain, and size are all calls that don't return records...
                // So don't use mycursor to get the records if you don't want them
                if (!defaultCount && !defaultExplain && !defaultSize)
                {
                    mycursor = collection.Find(qdoc).SetFields(Fields.Include(defaultFieldsInclude)).SetFields(Fields.Exclude(defaultFieldsExclude)).SetHint(new BsonDocument(defaultHint, 1))
                                .SetLimit(defaultLimit).SetSkip(defaultSkip).SetSortOrder(SortBy.Descending(defaultSortBy));
                }
            }

            if (!defaultCount && !defaultExplain && !defaultSize)
            {
                returnValues = AssembleMongoResults(mycursor);
            }
            #endregion
            #endregion

            return returnValues;
        }

